__NUXT_JSONP__("/features/order-balancer", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w){return {data:[{document:{slug:"order-balancer",description:"",title:"Order balancer",position:k,category:"Features",toc:[{id:l,depth:k,text:m},{id:n,depth:k,text:o}],body:{type:"root",children:[{type:b,tag:d,props:{},children:[{type:a,value:"Lorem ipsum"}]},{type:a,value:c},{type:b,tag:p,props:{id:l},children:[{type:b,tag:q,props:{ariaHidden:r,href:"#function-call-and-minmax",tabIndex:s},children:[{type:b,tag:t,props:{className:[u,v]},children:[]}]},{type:a,value:m}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"The following code calls order balancer function."}]},{type:a,value:c},{type:b,tag:e,props:{className:[f]},children:[{type:b,tag:g,props:{className:[h,i]},children:[{type:b,tag:j,props:{},children:[{type:a,value:"balancer(sendTokens = {\"USDC\": 100}, receiveTokens = {\"ETH\": 0.3})\n\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"The code below is equivalent to the code above."}]},{type:a,value:c},{type:b,tag:e,props:{className:[f]},children:[{type:b,tag:g,props:{className:[h,i]},children:[{type:b,tag:j,props:{},children:[{type:a,value:"balancer({\"self\": \"Ethereum\"}, \n            {\"self\": \"Ethereum\"}, \n            {\"USDC\": 100}, \n            {\"ETH\": 0.3}, \n            path = protocol.orderBalancer, \n            residual = min) \n\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This function call is automatically categorized as a swap function because the fromAddress and toAddress are both address of the vault. Although the order balancer itself may take actions such as borrow, stake and other to achive the end result."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"The \"min\" command minimizes the number of sendTokens sold, until 0.3 ETH is reached. While with the \"max\" command all of USDC would be sold to get the greatest amount of ETH. In this scenario the order balancer will minimize the number of USDC\u002FDAI liquidated to purchase exactly 0.3 ETH."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Number of receiveTokens serves as a limit order. If 0.3 ETH cannot be purchased then the transaction will fail. To make this order similar to a market order it should have a max residual with ETH amount set to 0. (more on this later)"}]},{type:a,value:c},{type:b,tag:e,props:{className:[f]},children:[{type:b,tag:g,props:{className:[h,i]},children:[{type:b,tag:j,props:{},children:[{type:a,value:"balancer(sendTokens = [{\"USDC\": 100}, {\"DAI\": 50}], \n            receiveTokens = [{\"ETH\": 0.3}, {\"MKR\": 3}], \n            min) \n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"The code above shows that multiple tokens can be swapped for multiple tokens. The advantage of this is it provides us with an exponential number of arbitrauge oppertunities when executing the order."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"The min command purchases the exact number of sendTokens while the amount of receiveTokens liquidated is minimized. While the max command liquidates all of the fromTokens and purchases as many toTokens as possible."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"With the min command, the liquidation will be in proportion to the ratio of USDC\u002FDAI, for every 1 DAI we will liquidate 2 USDC. The ratio of the residual will also be 2:1, i.e. 10 USDC to 5 DAI left after the transaction is complete."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"With the max command, if there is excess purchasing power tokens will be in the ratio of 10:1, i.e. 0.33ETH to 3.3 MKR or 0.6 ETH to 6 MKR."}]},{type:a,value:c},{type:b,tag:p,props:{id:n},children:[{type:b,tag:q,props:{ariaHidden:r,href:"#object-oriented",tabIndex:s},children:[{type:b,tag:t,props:{className:[u,v]},children:[]}]},{type:a,value:o}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"The prefered way to call the order balancer is to pass in objects created by Yieldster. This way the developer will be assisted with autocomplete and ensure that they do not type in the wrong token name."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Take the following example"}]},{type:a,value:c},{type:b,tag:e,props:{className:[f]},children:[{type:b,tag:g,props:{className:[h,i]},children:[{type:b,tag:j,props:{},children:[{type:a,value:"balancer([{\"0x\": \"Ethereum\", \"0x\": \"Polygon\"}, \n            [{\"0x\": \"Ethereum\", \"0x\": \"Polygon}, \n            {\"USDC\": 100}, \n            {\"USDC\": 100}, \n            path=\"orderBalancer\", \n            min) \n\n"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"The alternative would be below using objects."}]},{type:a,value:c},{type:b,tag:e,props:{className:[f]},children:[{type:b,tag:g,props:{className:[h,i]},children:[{type:b,tag:j,props:{},children:[{type:a,value:"balancer([self.address.ethereum, self.address.polygon], \n            [self.address.ethereum, self.address.polygon], \n            {token.USDC: 100}, \n            {token.USDC: 100}, \n            path=protocol.orderBalancer, \n            min) \n\n"}]}]}]}]},dir:"\u002Fen\u002Ffeatures",path:"\u002Fen\u002Ffeatures\u002Forder-balancer",extension:".md",createdAt:w,updatedAt:w,to:"\u002Ffeatures\u002Forder-balancer"},prev:{title:"Installation",path:"\u002Fen\u002Finstallation",to:"\u002Finstallation"},next:{title:"Visual Studio Code extension",path:"\u002Fen\u002Fvscode",to:"\u002Fvscode"}}],fetch:{},mutations:[]}}("text","element","\n","p","div","nuxt-content-highlight","pre","language-text","line-numbers","code",2,"function-call-and-minmax","function call and min\u002Fmax","object-oriented","Object oriented","h2","a","true",-1,"span","icon","icon-link","2022-04-25T20:06:38.312Z")));